#!/usr/bin/env python3
from base64 import b64decode
import urllib3
import subprocess
import time
import os
import json

help_notice = '''
Usage:

Put this script in PATH.
Have google-chrome/chromium/firefox/edge available (in PATH or location configured).

Ensure corresponding webdriver is in PATH or in the book repo or location configured.

Build it with `mdbook build` command.
Make sure the following exists in your `book.toml`:

```toml
[output.html]

[output.html.print]
enable = true

[output.pdf]
```

if you are using Windows, Put this script in the book repo,
add the following line to `[output.pdf]` in your `book.toml`:

```toml
command = "python ../../mdbook-pdf"
```
'''


def camel2dash(string):
    new_string = ''
    for letter in string:
        if letter.isupper():
            new_string += '-' + letter.lower()
        else:
            new_string += letter
    return new_string


if __name__ == '__main__':
    config = json.loads(input())

    if 'html' not in config['config']['output'].keys():
        print(
            'HTML backend not specified! \nPlease specify it in the book.toml: \n\n[output.html]')
        exit(1)

    root_dir = config['root']

    title = 'output'
    if 'title' in config['config']['book'].keys():
        title = config['config']['book']['title']
    destination = config['destination']

    saving_path = os.path.join(config['destination'], title + '.pdf')

    params = config['config']['output']['pdf']

    webdriver = ''
    if 'web-driver-path' in params.keys():
        if params['web-driver-path']:
            webdriver = os.path.abspath(os.path.expandvars(
                os.path.expanduser(params['web-driver-path'])))

    webdriver_name = ['chromedriver', 'geckodriver', 'msedgedriver']
    for name in webdriver_name:
        potential_webdriver = os.path.join(root_dir, name)
        if os.name == 'nt':
            potential_webdriver += '.exe'
        if not webdriver and os.path.exists(potential_webdriver) and os.path.isfile(potential_webdriver):
            webdriver = potential_webdriver
            break

    browser_binary = ''
    if 'web-binary-path' in params.keys():
        if params['web-binary-path']:
            browser_binary = os.path.abspath(os.path.expandvars(
                os.path.expanduser(params['web-binary-path'])))

    source_file = os.path.join(os.path.dirname(
        destination), 'html', 'print.html')

    # https://w3c.github.io/webdriver/#print-page
    settings = {
        "orientation": "portrait",
        "scale": 1,
        "background": True,
        "page": {},
        "pageWidth": 21.59,
        "pageHeight": 27.94,
        "margin": {},
        "marginTop": 1,
        "marginBottom": 1,
        "marginLeft": 1,
        "marginRight": 1,
        "shrinkToFit": True,
        "pageRanges": []
    }

    config_items_json = [
        "page",
        "margin",
        "pageRanges"
    ]

    # Load configs from book.toml
    for item in settings.keys():
        camel_item = camel2dash(item)
        if camel_item in params.keys():
            if item in config_items_json:
                settings[item] = json.loads(params[camel_item])
            else:
                settings[item] = params[camel_item]

    # https://github.com/puppeteer/puppeteer/blob/083ea41e943e2a20014279fcfceb23c98a1e4491/src/node/Launcher.ts#L168
    DEFAULT_ARGS = [
        # suppresses Save Password prompt window
        "--enable-automation",
        # do not block popups
        "--disable-popup-blocking",
        # Disable all chrome extensions entirely
        "--disable-extensions",
        # Disable various background network services, including extension updating,
        #   safe browsing service, upgrade detector, translate, UMA
        "--disable-background-networking",
        "--disable-background-timer-throttling",
        "--disable-backgrounding-occluded-windows",
        # Disable syncing to a Google account
        "--disable-sync",
        # Disable reporting to UMA, but allows for collection
        "--metrics-recording-only",
        # Disable installation of default apps on first run
        "--disable-default-apps",
        # Mute any audio
        "--mute-audio",
        # Skip first run wizards
        "--no-first-run",
        "--no-default-browser-check",
        # chromedriver flags
        "--disable-hang-monitor",
        "--disable-prompt-on-repost",
        "--disable-client-side-phishing-detection",
        "--password-store=basic",
        "--use-mock-keychain",
        "--disable-component-extensions-with-background-pages",
        "--disable-breakpad",
        "--disable-dev-shm-usage",
        "--disable-ipc-flooding-protection",
        "--disable-renderer-backgrounding",
        "--force-fieldtrials=*BackgroundTracing/default/",
        "--enable-features=NetworkService,NetworkServiceInProcess",
        "--unlimited-storage",
        "--disable-web-security",
        "--no-sandbox",
        "--disable-setuid-sandbox",
        "--disable-gpu",
        "--headless",
        # `site-per-process` affects `page.frames()`, see #4471
        # `TranslateUI` disables built-in Google Translate service
        "--disable-features=site-per-process,TranslateUI,BlinkGenPropertyTrees"
    ]

    success = False
    # Ensure printing.html is available
    for i in range(20):
        if os.path.exists(source_file) and os.path.isfile(source_file):
            try:
                with open(source_file, 'r') as f:
                    success = True
                    break
            except Exception:
                pass
        time.sleep(2)

    if not success:
        print(
            'Time out for finding printing.html! \nPlease ensure that in book.toml:\n\n[output.html.print]\n\nenable = true')
        exit(1)

    webdriver_config = {
        "capabilities": {
            "alwaysMatch": {
                "goog:chromeOptions": {
                    "binary": browser_binary,
                    "args": DEFAULT_ARGS,
                },
                "moz:firefoxOptions": {
                    "args": DEFAULT_ARGS,
                },
                "ms:edgeOptions": {
                    "binary": browser_binary,
                    "args": DEFAULT_ARGS,
                }
            }
        }
    }

    if "firefox" in browser_binary.lower():
        webdriver_config["capabilities"]["alwaysMatch"]["moz:firefoxOptions"]["binary"] = browser_binary

    success = False
    # Hope to fix unknown error: session deleted because of page crash
    for i in range(20):
        driver_base_url = 'http://127.0.0.1:'
        subp = None
        if not webdriver:
            for name in webdriver_name:
                try:
                    subp = subprocess.Popen(name, stdout=subprocess.PIPE)
                    break
                except FileNotFoundError:
                    pass
        else:
            subp = subprocess.Popen(webdriver, stdout=subprocess.PIPE)
        if not subp:
            print('No Webdriver Available!')
            exit(1)
        while True:
            subp_return = subp.stdout.readline().decode('utf-8').strip()
            if subp_return:
                break

        subp_return = subp_return.split(' ')
        address = subp_return[-1].strip()
        if address.isdigit():
            driver_base_url += address
        else:
            if ":" in address:
                driver_base_url = "http://" + address
            else:
                driver_base_url += "4444"

        time.sleep(2)
        http = urllib3.PoolManager()
        encoded_data = json.dumps(webdriver_config)
        resp = http.request('POST', driver_base_url +
                            '/session', body=encoded_data)
        session_data = json.loads(resp.data.decode('utf-8'))

        if resp.status == 200:
            session_id = session_data['value']['sessionId']
        else:
            raise Exception(resp.data.decode('utf-8'))

        data = {
            "url": f'file://{source_file}'
        }
        encoded_data = json.dumps(data)
        resp = http.request('POST', driver_base_url +
                            '/session/' + session_id + '/url', body=encoded_data)

        if not resp.status == 200:
            raise Exception(resp.data.decode('utf-8'))

        time.sleep(5)

        encoded_data = json.dumps(settings)

        try:
            resp = http.request(
                'POST', driver_base_url + '/session/' + session_id + '/print', body=encoded_data)

            if not resp.status == 200:
                raise Exception(resp.data.decode('utf-8'))
            success = True
            data = json.loads(resp.data.decode('utf-8'))['value']
        except Exception as e:
            print(e)
        finally:
            resp = http.request('DELETE', driver_base_url +
                                '/session/' + session_id)
            if not resp.status == 200:
                raise Exception(resp.data.decode('utf-8'))
            subp.kill()
            if success:
                break
            time.sleep(2)

    if not success:
        print(
            'Maybe you have a memory shortage or something wrong with your chrome driver, you can try to re-run it.')
        exit(1)

    # Decode the Base64 string, making sure that it contains only valid characters
    bytes = b64decode(data, validate=True)

    # Perform a basic validation to make sure that the result is a valid PDF file
    # Be aware! The magic number (file signature) is not 100% reliable solution to validate PDF files
    # Moreover, if you get Base64 from an untrusted source, you must sanitize the PDF contents
    if bytes[0:4] != b'%PDF':
        print('ValueError: Missing the PDF file signature!')
        exit(1)

    # Write the PDF contents to a local file
    with open(saving_path, 'wb') as f:
        f.write(bytes)

    print("PDF file saved to: " + saving_path)
